[.topic.intro]
== Camel CDI

====
How to use CDI as dependency injection container for an integration framework (Apache Camel)
====


[.topic.source]
== About Apache Camel

NOTE: Open-source _integration framework_ based on known Enterprise Integration Patterns

NOTE: Provides a variety of DSLs to write routing and mediation rules

NOTE: Provides support for _bean binding_ and seamless integration with DI frameworks

image::eip.gif[height="150"]


== !

[.statement]
Discover how we created CDI integration module for Camel


[.topic.source]
== Camel out of the box (NO CDI)

[source, subs="verbatim,quotes", role="smaller"]
----
class CamelMain {
    static CamelContext camelContext = new DefaultCamelContext();
    static CountDownLatch shutdownLatch = new CountDownLatch(1);
    public static void main(String[] args) {
        camelContext.addRoutes(new RouteBuilder() {
            public void configure() {
                from("file:inputDir?delay=1000").to("sjms:queue:outputDest"); <1>
            }
        });
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        Integer maxConnections = Integer.valueOf(camelContext
            .resolvePropertyPlaceholders("{{jms.queue.maxConnections}}"));
        component.setConnectionCount(maxConnections);
        camelContext.addComponent("sjms", component); // Registers the "sjms" component
        camelContext.start();
        shutdownLatch.await(); // Shutdown hook
        camelContext.stop();
    }
}
----
<1> This route watch a directory every second and send new files content to a JMS queue

[.topic.source]
== Basic CDI integration 1/2

[source, subs="verbatim,quotes"]
----
class FileToJmsRouteBean extends RouteBuilder {
    @Override
    public void configure() {
        from("file:inputDir?delay=1000").to("sjms:queue:outputDest");
    }
}
----

[source, subs="verbatim,quotes"]
----
class JmsComponentFactoryBean {
    @Produces
    @ApplicationScoped
    SjmsComponent sjmsComponent() {
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        return component;
    }
}
----


[.topic.source]
== Basic CDI integration 2/2

[source, subs="verbatim,quotes", role="smaller"]
----
@ApplicationScoped
class CamelContextBean extends DefaultCamelContext {
    @Inject
    CamelContextBean(FileToJmsRouteBean route, SjmsComponent sjmsComponent) {
        Integer maxConnections = Integer.valueOf(
            resolvePropertyPlaceholders("{{jms.queue.maxConnections}}"));
        sjmsComponent.setConnectionCount(maxConnections);
        addComponent("sjms", sjmsComponent);
        addRoutes(route);
    }
    @PostConstruct
    void postConstruct() {
        super.start();
    }
    @PreDestroy
    void preDestroy() {
        super.stop();
    }
}
----
TIP: We could have a lot more with advanced *CDI* features


[.topic.source]
== Our goals

. Avoid assembling and configuring the `CamelContext` manually

. Access CDI beans from the Camel DSL automatically
+
[source, subs="verbatim,quotes", role="smallest"]
----
.to("[highlight]#sjms#:queue:outputDest"); // Lookup by name (sjms) and type (Component)
----

. Support Camel annotations in CDI beans
+
[source, subs="verbatim,quotes", role="smallest"]
----
[highlight]#@PropertyInject#(value = "jms.queue.maxConnections", defaultValue = "10")
Integer maxConnections;
----


[.topic]
== Steps to integrate Camel and CDI

[.statement]
====
TIP: Manage the creation and the configuration of the `CamelContext` bean

TIP: Bind the `CamelContext` lifecycle to the CDI container events

TIP: Implement the Camel SPI to look up CDI bean references

TIP: Use a custom `InjectionTarget` for CDI beans containing Camel annotations

TIP: Use the Magic
====


[.topic.source]
== How to achieve this?

TIP: We need to write an extension that will:

. Declare a `CamelContext` bean if no such bean is already deployed by observing the `AfterBeanDiscovery` lifecycle event
. Instantiate the beans of type `RouteBuilder` and add them to the Camel context
. Start (resp. stop) the Camel context when the `AfterDeploymentValidation` event is fired (resp. the `BeforeShutdown` event)
. Customize the Camel context to query the `BeanManager` to lookup CDI beans by name and type
. Detect CDI beans containing Camel annotations by observing the `ProcessAnnotatedType` and modify how they get injected by observing the `ProcessInjectionTarget` lifecycle event


[.topic.source]
== So we will `@Observes` these 5 events to add our features

[plantuml, "lifecycle-PAT-PIT-ABD-ADV-BS", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  FontSize 20
  FontName Consolas
  FontColor #337788
  ArrowColor #888888
  BorderColor #337788
  BackgroundColor #white

  FontColor<< Internal >> #888888
  BorderColor<< Internal >> #888888
  BackgroundColor<< Internal >> #white

  FontColor<< Once >> #BB3322
  BorderColor<< Once >> #BB3322
  BackgroundColor<< Once >> #white

  FontColor<< Highlight >> white
  BorderColor<< Highlight >> #337788
  BackgroundColor<< Highlight >> #337788

  FontColor<< HighlightOnce >> white
  BorderColor<< HighlightOnce >> #BB3322
  BackgroundColor<< HighlightOnce >> #BB3322
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" << Once >>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType" << Highlight >>
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget" << Highlight >>
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean"
-right-> "Process\nProducer"
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << HighlightOnce >>
-down-> "After\nDeployment\nValidation" << HighlightOnce >>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << HighlightOnce >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

include::legend.adoc[]


[.topic.source]
== Adding the `CamelContext` bean

TIP: Automatically add a `CamelContext` bean if no such a bean already exists in the deployment archive

icon:question-circle[] How to detect if a bean exists in the deployment?

TIP: By querying the `BeanManager` during the `AfterBeanDiscovery` lifecycle event

[source, subs="verbatim,quotes",role="smaller"]
----
public class CamelExtension implements Extension {
    void addCamelContextBean(@Observes [highlight]#AfterBeanDiscovery# abd, BeanManager bm) {
        Set<Bean<?>> beans = bm.[highlight]#getBeans#(CamelContext.class);
        if (beans.isEmpty())
            // No CamelContext bean is already deployed
    }
}
----


[.topic.source]
== Declaring a bean programmatically

icon:question-circle[] How to add a bean programmatically?

TIP: We need to implement the `Bean` SPI

[source]
----
public interface Bean<T> extends Contextual<T>, BeanAttributes<T> {
    public Class<?> getBeanClass();
    public Set<InjectionPoint> getInjectionPoints();
    public T create(CreationalContext<T> creationalContext); // Contextual<T>
    public void destroy(T instance, CreationalContext<T> creationalContext);
    public Set<Type> getTypes(); // BeanAttributes<T>
    public Set<Annotation> getQualifiers();
    public Class<? extends Annotation> getScope();
    public String getName();
    public Set<Class<? extends Annotation>> getStereotypes();
    public boolean isAlternative();
}
----


[.topic.source]
== Implementing the `Bean` SPI

[source, subs="verbatim,quotes", role="smaller"]
----
class CamelContextBean implements Bean<DefaultCamelContext> {
    private final Set<Annotation> qualifiers = new HashSet<>(Arrays.asList(new AnnotationLiteral<Any>(){},
                                                                       new AnnotationLiteral<Default>(){}));
    private final Set<Type> types;

    public CamelContextBean(BeanManager bm) {
        types = bm.createAnnotatedType(DefaultCamelContext.class).getTypeClosure();
    }
    public Class<? extends Annotation> getScope() {
        return ApplicationScoped.class;
    }
    public Set<Annotation> getQualifiers() {
        return Collections.unmodifiableSet(qualifiers);
    }
    public Set<Type> getTypes() {
        return Collections.unmodifiableSet(types);
    }
    public DefaultCamelContext create(CreationalContext<DefaultCamelContext> creational) {
        return new DefaultCamelContext();
    }
    public void destroy(DefaultCamelContext instance, CreationalContext<DefaultCamelContext> creational) {
    }
    ...
----


[.topic.source]
== Implementing the `Bean` SPI (continued)

[source, subs="verbatim,quotes", role="smaller"]
----
    ...
    public Class<?> getBeanClass() {
        return DefaultCamelContext.class;
    }
    public Set<InjectionPoint> getInjectionPoints() {
        return Collections.emptySet();
    }
    public String getName() { // Only called for @Named bean
        return "";
    }
    public Set<Class<? extends Annotation>> getStereotypes() {
        return Collections.emptySet();
    }
    public boolean isAlternative() {
        return false;
    }
    public boolean isNullable() { // Deprecated since CDI 1.1
        return false;
    }
}
----


[.topic.source]
== Adding a programmatic bean to the deployment

TIP: Then add the `CamelContextBean` bean programmatically by observing the `AfterBeanDiscovery` lifecyle event

[source, subs="verbatim,quotes"]
----
public class CamelExtension implements Extension {

    void addCamelContextBean(@Observes [highlight]#AfterBeanDiscovery# abd, BeanManager bm) {
        Set<Bean<?>> beans = bm.getBeans(CamelContext.class);
        if (beans.isEmpty())
            abd.[highlight]#addBean#(new CamelContextBean(bm));
    }
}
----


[.topic.source]
== Instantiate and assemble the Camel context

TIP: Instantiate the `CamelContext` bean and the `RouteBuilder` beans in the `AfterDeploymentValidation` lifecycle event

[source, subs="verbatim,quotes"]
----
public class CamelExtension implements Extension {
    ...
    void configureContext(@Observes [highlight]#AfterDeploymentValidation# adv, BeanManager bm) {
        CamelContext context = getReference(bm, CamelContext.class);
        for (Bean<?> bean : bm.getBeans(RoutesBuilder.class))
            context.[highlight]#addRoutes#(getReference(bm, RouteBuilder.class, bean));
    }
    <T> T getReference(BeanManager bm, Class<T> type) {
        return getReference(bm, type, bm.resolve(bm.getBeans(type)));
    }
    <T> T getReference(BeanManager bm, Class<T> type, Bean<?> bean) {
        return (T) bm.getReference(bean, type, bm.createCreationalContext(bean));
    }
}
----


[.topic.source]
== Managed the Camel context lifecycle

TIP: Start (resp. stop) the Camel context when the `AfterDeploymentValidation` event is fired (resp. the `BeforeShutdown`)

[source, subs="verbatim,quotes"]
----
public class CamelExtension implements Extension {

    private CamelContext context;

    void configureContext(@Observes [highlight]#AfterDeploymentValidation# adv, BeanManager bm) {
        context = getReference(bm, CamelContext.class);
        for (Bean<?> bean : bm.getBeans(RoutesBuilder.class)
            context.addRoutes(getReference(bm, RouteBuilder.class, bean);
        [highlight]#context.start()#;
    }
    void stopCamelContext(@Observes [highlight]#BeforeShutdown# bs, BeanManager bm) {
        [highlight]#context.stop();#
    }
    ...
}
----


[.topic]
== First goal achieved

[.statement]
====
TIP: We can get rid of the following code:

[source, subs="verbatim,quotes",role="smaller"]
----
@ApplicationScoped
class CamelContextBean extends DefaultCamelContext {
    @Inject
    CamelContextBean([highlight]#FileToJmsRouteBean route,# SjmsComponent sjmsComponent) {
        Integer maxConnections = Integer.valueOf(
            resolvePropertyPlaceholders("{{jms.queue.maxConnections}}"));
        sjmsComponent.setConnectionCount(maxConnections);
        addComponent("sjms", sjmsComponent);
        [highlight]#addRoutes(route);#
    }
    [highlight]#@PostConstruct#
    [highlight]#void postConstruct() {#
        [highlight]#super.start();#
    [highlight]#}#
    [highlight]#@PreDestroy#
    [highlight]#void preDestroy() {#
        [highlight]#super.stop();#
    [highlight]#}#
}
----

====


[.topic.source]
== Second goal: Access CDI beans from the Camel DSL

icon:question-circle[] How to retrieve CDI beans from the Camel DSL?

[source, subs="verbatim,quotes"]
----
.to("[highlight]#sjms#:queue:outputDest"); // Lookup by name (sjms) and type (Component)

// And also...
.bean([highlight]#MyBean.class#); // Lookup by type and Default qualifier
.beanRef([highlight]#"beanName"#); // Lookup by name
----

TIP: Implement the Camel registry SPI and use the `BeanManager` to lookup for CDI bean contextual references by name and type


[.topic.source]
== Implement the Camel registry SPI

[source, subs="verbatim,quotes"]
----
class CdiRegistry implements Registry {
    private final BeanManager bm;
    public CdiRegistry(BeanManager bm) {
        this.bm = bm;
    }
    public <T> T lookupByNameAndType(String name, Class<T> type) {
        return getReference(bm, type, bm.resolve(bm.getBeans(name)));
    }
    public <T> Set<T> findByType(Class<T> type) {
        return getReference(bm, type, bm.resolve(bm.getBeans(type)));
    }
    public Object lookupByName(String name) {
        return lookupByNameAndType(name, Object.class);
    }
    <T> T getReference(BeanManager bm, Type type, Bean<?> bean) {
        return (T) bm.getReference(bean, type, bm.createCreationalContext(bean));
    }
}
----


[.topic.source]
== Add the `CdiRegistry` to the Camel context

[source, subs="verbatim,quotes"]
----
public class CamelExtension implements Extension {
    ...
    void configureContext(@Observes AfterDeploymentValidation adv, BeanManager bm) {
        context = getReference(bm, DefaultCamelContext.class);
        for (Bean<?> bean : bm.getBeans(RoutesBuilder.class)
            context.addRoutes(getReference(bm, RouteBuilder.class, bean);

        [highlight]#context.setRegistry(new CdiRegistry(bm));#
        context.start();
    }
    ...
}
----


[.topic]
== Second goal achieved 1/2

[.statement]
====
TIP: We can declare the `sjms` component with the `@Named` qualifier

[source, subs="verbatim,quotes"]
----
class JmsComponentFactoryBean {

    @Produces
    [highlight]#@Named("sjms")#
    @ApplicationScoped
    Component sjmsComponent() {
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        return component;
    }
}
----
...
====


[.topic]
== Second goal achieved 2/2

[.statement]
====

TIP: And get rid of the code related to the `sjms` component registration

[source, subs="verbatim,quotes",role="smaller"]
----
@ApplicationScoped
class CamelContextBean extends DefaultCamelContext {
    @Inject
    CamelContextBean([highlight]#FileToJmsRouteBean route,# SjmsComponent sjmsComponent) {
        Integer maxConnections = Integer.valueOf(
            resolvePropertyPlaceholders("{{jms.queue.maxConnections}}"));
        sjmsComponent.setConnectionCount(maxConnections);
        [highlight]#addComponent("sjms", sjmsComponent)#;
        [highlight]#addRoutes(route);#
    }
    [highlight]#@PostConstruct#
    [highlight]#void postConstruct() {#
        [highlight]#super.start();#
    [highlight]#}#
    [highlight]#@PreDestroy#
    [highlight]#void preDestroy() {#
        [highlight]#super.stop();#
    }
}
----

====


[.topic.source]
== Third goal: Support Camel annotations in CDI beans

TIP: Camel provides a set of DI framework agnostic annotations for resource injection

[source, subs="verbatim,quotes"]
----
[highlight]#@PropertyInject#(value = "jms.queue.maxConnections", defaultValue = "10")
Integer maxConnections;

// But also...
[highlight]#@EndpointInject#(uri="jms:queue:foo")
Endpoint endpoint;

[highlight]#@BeanInject#("foo")
FooBean foo;
----

icon:question-circle[] How to support custom annotations injection?


[.topic.source]
== How to support custom annotations injection?

TIP: Create a custom `InjectionTarget` that uses the default Camel bean post processor `DefaultCamelBeanPostProcessor`

[source, subs="verbatim,quotes"]
----
public interface InjectionTarget<T> extends Producer<T> {
    [highlight]#public void inject(T instance, CreationalContext<T> ctx);#
    public void postConstruct(T instance);
    public void preDestroy(T instance);
}
----

TIP: Hook it into the CDI injection mechanism by observing the `ProcessInjectionTarget` lifecycle event

TIP: Only for beans containing Camel annotations by observing the `ProcessAnnotatedType` lifecycle and using `@WithAnnotations`


[.topic.source]
== Create a custom `InjectionTarget`

[source, subs="verbatim,quotes"]
----
class CamelInjectionTarget<T> [highlight]#implements InjectionTarget<T># {

  final DefaultCamelBeanPostProcessor processor = new DefaultCamelBeanPostProcessor();

  final InjectionTarget<T> delegate;

  CamelInjectionTarget(InjectionTarget<T> target) {
    delegate = target;
  }

  public void [highlight]#inject#(T instance, CreationalContext<T> ctx) {
    [highlight]#processor.postProcessBeforeInitialization(instance)#; <1>
    delegate.inject(instance, ctx);
  }
  ...
}
----
<1> Call the Camel default bean post-processor after CDI injection


[.topic.source]
== Register the custom `InjectionTarget`

TIP: Observe the `ProcessInjectionTarget` lifecyle event and set the `CamelInjectionTarget`

[source]
----
public interface ProcessInjectionTarget<X> {
    public AnnotatedType<X> getAnnotatedType();
    public InjectionTarget<X> getInjectionTarget();
    public void setInjectionTarget(InjectionTarget<X> injectionTarget);
    public void addDefinitionError(Throwable t);
}
----

[source, subs="verbatim,quotes"]
----
class CamelExtension implements Extension {

  <T> void camelBeansPostProcessor(@Observes [highlight]#ProcessInjectionTarget<T># pit) {
      pit.[highlight]#setInjectionTarget#(new CamelInjectionTarget<T>(pit.getInjectionTarget()));
  }
}
----


[.topic.source]
== But only for beans containing Camel annotations

[source, subs="verbatim,quotes"]
----
class CamelExtension implements Extension {
  final Set<AnnotatedType<?>> camelBeans = new HashSet<>();

  void camelAnnotations(@Observes [highlight]#@WithAnnotations({BeanInject.class, <1>
      Consume.class, EndpointInject.class, Produce.class, PropertyInject.class})#
      ProcessAnnotatedType<?> pat) {
        camelBeans.add(pat.getAnnotatedType());
  }

  <T> void camelBeansPostProcessor(@Observes [highlight]#ProcessInjectionTarget<T># pit) {
      if (camelBeans.contains(pit.getAnnotatedType())) <2>
        pit.[highlight]#setInjectionTarget#(new CamelInjectionTarget<>(pit.getInjectionTarget()));
  }
}
----
<1> Detect all the types containing Camel annotations with `@WithAnnotations`
<2> Decorate the `InjectionTarget` corresponding to these types with a custom post-processor


[.topic]
== Third goal achieved 1/2

[.statement]
====
TIP: We can add Camel annotations in CDI beans

[source, subs="verbatim,quotes",role="smaller"]
----
class JmsComponentFactoryBean {

    [highlight]#@PropertyInject(value = "jms.queue.maxConnections", defaultValue = "10")#
    Integer maxConnections;

    @Produces
    @Named("sjms")
    @ApplicationScoped
    SjmsComponent sjmsComponent() {
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        [highlight]#component.setConnectionCount(maxConnections);#
        return component;
    }
}
----

====


[.topic]
== Third goal achieved 2/2

[.statement]
====

TIP: And get rid of all the code related to the Camel context config

[source, subs="verbatim,quotes",role="smaller"]
----
[highlight]#@ApplicationScoped#
[highlight]#class CamelContextBean extends DefaultCamelContext {#
    [highlight]#@Inject#
    [highlight]#CamelContextBean(FileToJmsRouteBean route, SjmsComponent sjmsComponent) {#
        [highlight]#Integer maxConnections = Integer.valueOf(#
            [highlight]#resolvePropertyPlaceholders("{{jms.queue.maxConnections}}"));#
        [highlight]#sjmsComponent.setConnectionCount(maxConnections);#
        [highlight]#addComponent("sjms", sjmsComponent)#;
        [highlight]#addRoutes(route);#
    [highlight]#}#
    [highlight]#@PostConstruct#
    [highlight]#void postConstruct() {#
        [highlight]#super.start();#
    [highlight]#}#
    [highlight]#@PreDestroy#
    [highlight]#void preDestroy() {#
        [highlight]#super.stop();#
    [highlight]#}#
[highlight]#}#
----

====
